{"ast":null,"code":"import _defineProperty from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/defineProperty\";import _toConsumableArray from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";import _objectSpread from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _slicedToArray from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{createAsyncThunk,createSlice}from'@reduxjs/toolkit';import{nftSources}from'config/constants/nfts';import{getAddress}from'utils/addressHelpers';import{getErc721Contract}from'utils/contractHelpers';import{getNftByTokenId}from'utils/collectibles';var initialState={isInitialized:false,isLoading:true,data:{}};// Thunks\nexport var fetchWalletNfts=createAsyncThunk('collectibles/fetchWalletNfts',/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(account){var nftSourcePromises,nftSourceData;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:// For each nft source get nft data\nnftSourcePromises=Object.keys(nftSources).map(/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(nftSourceType){var addressObj,address,contract,getTokenIdAndData,balanceOfResponse,balanceOf,nftDataFetchPromises,i,nftData;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:addressObj=nftSources[nftSourceType].address;address=getAddress(addressObj);contract=getErc721Contract(address);getTokenIdAndData=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(index){var tokenIdBn,tokenId,walletNft;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;_context.next=3;return contract.tokenOfOwnerByIndex(account,index);case 3:tokenIdBn=_context.sent;tokenId=tokenIdBn.toNumber();_context.next=7;return getNftByTokenId(address,tokenId);case 7:walletNft=_context.sent;return _context.abrupt(\"return\",[tokenId,walletNft.identifier]);case 11:_context.prev=11;_context.t0=_context[\"catch\"](0);console.error('getTokenIdAndData',_context.t0);return _context.abrupt(\"return\",null);case 15:case\"end\":return _context.stop();}}},_callee,null,[[0,11]]);}));return function getTokenIdAndData(_x3){return _ref3.apply(this,arguments);};}();_context2.next=6;return contract.balanceOf(account);case 6:balanceOfResponse=_context2.sent;balanceOf=balanceOfResponse.toNumber();if(!(balanceOf===0)){_context2.next=10;break;}return _context2.abrupt(\"return\",[]);case 10:nftDataFetchPromises=[];// For each index get the tokenId and data associated with it\nfor(i=0;i<balanceOf;i++){nftDataFetchPromises.push(getTokenIdAndData(i));}_context2.next=14;return Promise.all(nftDataFetchPromises);case 14:nftData=_context2.sent;return _context2.abrupt(\"return\",nftData);case 16:case\"end\":return _context2.stop();}}},_callee2);}));return function(_x2){return _ref2.apply(this,arguments);};}());_context3.next=3;return Promise.all(nftSourcePromises);case 3:nftSourceData=_context3.sent;return _context3.abrupt(\"return\",nftSourceData.flat());case 5:case\"end\":return _context3.stop();}}},_callee3);}));return function(_x){return _ref.apply(this,arguments);};}());export var collectiblesSlice=createSlice({name:'collectibles',initialState:initialState,reducers:{},extraReducers:function extraReducers(builder){builder.addCase(fetchWalletNfts.pending,function(state){state.isLoading=true;});builder.addCase(fetchWalletNfts.fulfilled,function(state,action){state.isLoading=false;state.isInitialized=true;state.data=action.payload.reduce(function(accum,association){if(!association){return accum;}var _ref4=association,_ref5=_slicedToArray(_ref4,2),tokenId=_ref5[0],identifier=_ref5[1];return _objectSpread(_objectSpread({},accum),{},_defineProperty({},identifier,accum[identifier]?[].concat(_toConsumableArray(accum[identifier]),[tokenId]):[tokenId]));},{});});}});export default collectiblesSlice.reducer;","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/pancake-frontend/src/state/collectibles/index.ts"],"names":["createAsyncThunk","createSlice","nftSources","getAddress","getErc721Contract","getNftByTokenId","initialState","isInitialized","isLoading","data","fetchWalletNfts","account","nftSourcePromises","Object","keys","map","nftSourceType","addressObj","address","contract","getTokenIdAndData","index","tokenOfOwnerByIndex","tokenIdBn","tokenId","toNumber","walletNft","identifier","console","error","balanceOf","balanceOfResponse","nftDataFetchPromises","i","push","Promise","all","nftData","nftSourceData","flat","collectiblesSlice","name","reducers","extraReducers","builder","addCase","pending","state","fulfilled","action","payload","reduce","accum","association","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice } from '@reduxjs/toolkit'\nimport { CollectiblesState } from 'state/types'\nimport { nftSources } from 'config/constants/nfts'\nimport { NftType } from 'config/constants/types'\nimport { getAddress } from 'utils/addressHelpers'\nimport { getErc721Contract } from 'utils/contractHelpers'\nimport { getNftByTokenId } from 'utils/collectibles'\nimport { ethers } from 'ethers'\n\nconst initialState: CollectiblesState = {\n  isInitialized: false,\n  isLoading: true,\n  data: {},\n}\n\ntype NftSourceItem = [number, string]\n\n// Thunks\nexport const fetchWalletNfts = createAsyncThunk<NftSourceItem[], string>(\n  'collectibles/fetchWalletNfts',\n  async (account) => {\n    // For each nft source get nft data\n    const nftSourcePromises = Object.keys(nftSources).map(async (nftSourceType) => {\n      const { address: addressObj } = nftSources[nftSourceType as NftType]\n      const address = getAddress(addressObj)\n      const contract = getErc721Contract(address)\n\n      const getTokenIdAndData = async (index: number) => {\n        try {\n          const tokenIdBn: ethers.BigNumber = await contract.tokenOfOwnerByIndex(account, index)\n          const tokenId = tokenIdBn.toNumber()\n\n          const walletNft = await getNftByTokenId(address, tokenId)\n          return [tokenId, walletNft.identifier]\n        } catch (error) {\n          console.error('getTokenIdAndData', error)\n          return null\n        }\n      }\n\n      const balanceOfResponse = await contract.balanceOf(account)\n      const balanceOf = balanceOfResponse.toNumber()\n\n      if (balanceOf === 0) {\n        return []\n      }\n\n      const nftDataFetchPromises = []\n\n      // For each index get the tokenId and data associated with it\n      for (let i = 0; i < balanceOf; i++) {\n        nftDataFetchPromises.push(getTokenIdAndData(i))\n      }\n\n      const nftData = await Promise.all(nftDataFetchPromises)\n      return nftData\n    })\n\n    const nftSourceData = await Promise.all(nftSourcePromises)\n\n    return nftSourceData.flat()\n  },\n)\n\nexport const collectiblesSlice = createSlice({\n  name: 'collectibles',\n  initialState,\n  reducers: {},\n  extraReducers: (builder) => {\n    builder.addCase(fetchWalletNfts.pending, (state) => {\n      state.isLoading = true\n    })\n    builder.addCase(fetchWalletNfts.fulfilled, (state, action) => {\n      state.isLoading = false\n      state.isInitialized = true\n      state.data = action.payload.reduce((accum, association) => {\n        if (!association) {\n          return accum\n        }\n\n        const [tokenId, identifier] = association as NftSourceItem\n\n        return {\n          ...accum,\n          [identifier]: accum[identifier] ? [...accum[identifier], tokenId] : [tokenId],\n        }\n      }, {})\n    })\n  },\n})\n\nexport default collectiblesSlice.reducer\n"]},"metadata":{},"sourceType":"module"}