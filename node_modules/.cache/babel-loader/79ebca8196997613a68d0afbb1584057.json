{"ast":null,"code":"var _s = $RefreshSig$();\n\nimport { useState, useEffect } from 'react';\nimport { ChainId } from '@pancakeswap/sdk';\nimport { useFarms, usePriceCakeBusd } from 'state/farms/hooks';\nimport { useAppDispatch } from 'state';\nimport { fetchFarmsPublicDataAsync, nonArchivedFarms } from 'state/farms';\nimport { getFarmApr } from 'utils/apr';\nimport BigNumber from 'bignumber.js';\nimport { orderBy } from 'lodash';\nvar FetchStatus;\n\n(function (FetchStatus) {\n  FetchStatus[\"NOT_FETCHED\"] = \"not-fetched\";\n  FetchStatus[\"FETCHING\"] = \"fetching\";\n  FetchStatus[\"SUCCESS\"] = \"success\";\n  FetchStatus[\"FAILED\"] = \"failed\";\n})(FetchStatus || (FetchStatus = {}));\n\nconst useGetTopFarmsByApr = isIntersecting => {\n  _s();\n\n  const dispatch = useAppDispatch();\n  const {\n    data: farms\n  } = useFarms();\n  const [fetchStatus, setFetchStatus] = useState(FetchStatus.NOT_FETCHED);\n  const [topFarms, setTopFarms] = useState([null, null, null, null, null]);\n  const cakePriceBusd = usePriceCakeBusd();\n  useEffect(() => {\n    const fetchFarmData = async () => {\n      setFetchStatus(FetchStatus.FETCHING);\n      const activeFarms = nonArchivedFarms.filter(farm => farm.pid !== 0 && farm.multiplier !== '0X');\n\n      try {\n        await dispatch(fetchFarmsPublicDataAsync(activeFarms.map(farm => farm.pid)));\n        setFetchStatus(FetchStatus.SUCCESS);\n      } catch (e) {\n        console.error(e);\n        setFetchStatus(FetchStatus.FAILED);\n      }\n    };\n\n    if (isIntersecting && fetchStatus === FetchStatus.NOT_FETCHED) {\n      fetchFarmData();\n    }\n  }, [dispatch, setFetchStatus, fetchStatus, topFarms, isIntersecting]);\n  useEffect(() => {\n    const getTopFarmsByApr = farmsState => {\n      const farmsWithPrices = farmsState.filter(farm => farm.lpTotalInQuoteToken && farm.quoteToken.busdPrice);\n      const farmsWithApr = farmsWithPrices.map(farm => {\n        const totalLiquidity = new BigNumber(farm.lpTotalInQuoteToken).times(farm.quoteToken.busdPrice);\n        const {\n          cakeRewardsApr,\n          lpRewardsApr\n        } = getFarmApr(new BigNumber(farm.poolWeight), cakePriceBusd, totalLiquidity, farm.lpAddresses[ChainId.MAINNET]);\n        return { ...farm,\n          apr: cakeRewardsApr,\n          lpRewardsApr\n        };\n      });\n      const sortedByApr = orderBy(farmsWithApr, farm => farm.apr + farm.lpRewardsApr, 'desc');\n      setTopFarms(sortedByApr.slice(0, 5));\n    };\n\n    if (fetchStatus === FetchStatus.SUCCESS && !topFarms[0]) {\n      getTopFarmsByApr(farms);\n    }\n  }, [setTopFarms, farms, fetchStatus, cakePriceBusd, topFarms]);\n  return {\n    topFarms\n  };\n};\n\n_s(useGetTopFarmsByApr, \"U2Lq+aj8vXjphreon5g1fsB+Dzo=\", false, function () {\n  return [useAppDispatch, useFarms, usePriceCakeBusd];\n});\n\nexport default useGetTopFarmsByApr;","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/apphocvienstock/src/views/Home/hooks/useGetTopFarmsByApr.tsx"],"names":["useState","useEffect","ChainId","useFarms","usePriceCakeBusd","useAppDispatch","fetchFarmsPublicDataAsync","nonArchivedFarms","getFarmApr","BigNumber","orderBy","FetchStatus","useGetTopFarmsByApr","isIntersecting","dispatch","data","farms","fetchStatus","setFetchStatus","NOT_FETCHED","topFarms","setTopFarms","cakePriceBusd","fetchFarmData","FETCHING","activeFarms","filter","farm","pid","multiplier","map","SUCCESS","e","console","error","FAILED","getTopFarmsByApr","farmsState","farmsWithPrices","lpTotalInQuoteToken","quoteToken","busdPrice","farmsWithApr","totalLiquidity","times","cakeRewardsApr","lpRewardsApr","poolWeight","lpAddresses","MAINNET","apr","sortedByApr","slice"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react'\nimport { ChainId } from '@pancakeswap/sdk'\nimport { useFarms, usePriceCakeBusd } from 'state/farms/hooks'\nimport { useAppDispatch } from 'state'\nimport { fetchFarmsPublicDataAsync, nonArchivedFarms } from 'state/farms'\nimport { getFarmApr } from 'utils/apr'\nimport BigNumber from 'bignumber.js'\nimport { orderBy } from 'lodash'\nimport { FarmWithStakedValue } from 'views/Farms/components/FarmCard/FarmCard'\nimport { Farm } from 'state/types'\n\nenum FetchStatus {\n  NOT_FETCHED = 'not-fetched',\n  FETCHING = 'fetching',\n  SUCCESS = 'success',\n  FAILED = 'failed',\n}\n\nconst useGetTopFarmsByApr = (isIntersecting: boolean) => {\n  const dispatch = useAppDispatch()\n  const { data: farms } = useFarms()\n  const [fetchStatus, setFetchStatus] = useState(FetchStatus.NOT_FETCHED)\n  const [topFarms, setTopFarms] = useState<FarmWithStakedValue[]>([null, null, null, null, null])\n  const cakePriceBusd = usePriceCakeBusd()\n\n  useEffect(() => {\n    const fetchFarmData = async () => {\n      setFetchStatus(FetchStatus.FETCHING)\n      const activeFarms = nonArchivedFarms.filter((farm) => farm.pid !== 0 && farm.multiplier !== '0X')\n      try {\n        await dispatch(fetchFarmsPublicDataAsync(activeFarms.map((farm) => farm.pid)))\n        setFetchStatus(FetchStatus.SUCCESS)\n      } catch (e) {\n        console.error(e)\n        setFetchStatus(FetchStatus.FAILED)\n      }\n    }\n\n    if (isIntersecting && fetchStatus === FetchStatus.NOT_FETCHED) {\n      fetchFarmData()\n    }\n  }, [dispatch, setFetchStatus, fetchStatus, topFarms, isIntersecting])\n\n  useEffect(() => {\n    const getTopFarmsByApr = (farmsState: Farm[]) => {\n      const farmsWithPrices = farmsState.filter((farm) => farm.lpTotalInQuoteToken && farm.quoteToken.busdPrice)\n      const farmsWithApr: FarmWithStakedValue[] = farmsWithPrices.map((farm) => {\n        const totalLiquidity = new BigNumber(farm.lpTotalInQuoteToken).times(farm.quoteToken.busdPrice)\n        const { cakeRewardsApr, lpRewardsApr } = getFarmApr(\n          new BigNumber(farm.poolWeight),\n          cakePriceBusd,\n          totalLiquidity,\n          farm.lpAddresses[ChainId.MAINNET],\n        )\n        return { ...farm, apr: cakeRewardsApr, lpRewardsApr }\n      })\n\n      const sortedByApr = orderBy(farmsWithApr, (farm) => farm.apr + farm.lpRewardsApr, 'desc')\n      setTopFarms(sortedByApr.slice(0, 5))\n    }\n\n    if (fetchStatus === FetchStatus.SUCCESS && !topFarms[0]) {\n      getTopFarmsByApr(farms)\n    }\n  }, [setTopFarms, farms, fetchStatus, cakePriceBusd, topFarms])\n\n  return { topFarms }\n}\n\nexport default useGetTopFarmsByApr\n"]},"metadata":{},"sourceType":"module"}