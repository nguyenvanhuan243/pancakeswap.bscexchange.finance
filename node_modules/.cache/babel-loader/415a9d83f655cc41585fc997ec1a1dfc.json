{"ast":null,"code":"import _objectSpread from\"/Users/nguyenvanhuan243/Documents/apphocvienstock/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/Users/nguyenvanhuan243/Documents/apphocvienstock/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/nguyenvanhuan243/Documents/apphocvienstock/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import _slicedToArray from\"/Users/nguyenvanhuan243/Documents/apphocvienstock/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import{useState,useEffect}from'react';import{ChainId}from'@pancakeswap/sdk';import{useFarms,usePriceCakeBusd}from'state/farms/hooks';import{useAppDispatch}from'state';import{fetchFarmsPublicDataAsync,nonArchivedFarms}from'state/farms';import{getFarmApr}from'utils/apr';import BigNumber from'bignumber.js';import{orderBy}from'lodash';var FetchStatus;(function(FetchStatus){FetchStatus[\"NOT_FETCHED\"]=\"not-fetched\";FetchStatus[\"FETCHING\"]=\"fetching\";FetchStatus[\"SUCCESS\"]=\"success\";FetchStatus[\"FAILED\"]=\"failed\";})(FetchStatus||(FetchStatus={}));var useGetTopFarmsByApr=function useGetTopFarmsByApr(isIntersecting){var dispatch=useAppDispatch();var _useFarms=useFarms(),farms=_useFarms.data;var _useState=useState(FetchStatus.NOT_FETCHED),_useState2=_slicedToArray(_useState,2),fetchStatus=_useState2[0],setFetchStatus=_useState2[1];var _useState3=useState([null,null,null,null,null]),_useState4=_slicedToArray(_useState3,2),topFarms=_useState4[0],setTopFarms=_useState4[1];var cakePriceBusd=usePriceCakeBusd();useEffect(function(){var fetchFarmData=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(){var activeFarms;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:setFetchStatus(FetchStatus.FETCHING);activeFarms=nonArchivedFarms.filter(function(farm){return farm.pid!==0&&farm.multiplier!=='0X';});_context.prev=2;_context.next=5;return dispatch(fetchFarmsPublicDataAsync(activeFarms.map(function(farm){return farm.pid;})));case 5:setFetchStatus(FetchStatus.SUCCESS);_context.next=12;break;case 8:_context.prev=8;_context.t0=_context[\"catch\"](2);console.error(_context.t0);setFetchStatus(FetchStatus.FAILED);case 12:case\"end\":return _context.stop();}}},_callee,null,[[2,8]]);}));return function fetchFarmData(){return _ref.apply(this,arguments);};}();if(isIntersecting&&fetchStatus===FetchStatus.NOT_FETCHED){fetchFarmData();}},[dispatch,setFetchStatus,fetchStatus,topFarms,isIntersecting]);useEffect(function(){var getTopFarmsByApr=function getTopFarmsByApr(farmsState){var farmsWithPrices=farmsState.filter(function(farm){return farm.lpTotalInQuoteToken&&farm.quoteToken.busdPrice;});var farmsWithApr=farmsWithPrices.map(function(farm){var totalLiquidity=new BigNumber(farm.lpTotalInQuoteToken).times(farm.quoteToken.busdPrice);var _getFarmApr=getFarmApr(new BigNumber(farm.poolWeight),cakePriceBusd,totalLiquidity,farm.lpAddresses[ChainId.MAINNET]),cakeRewardsApr=_getFarmApr.cakeRewardsApr,lpRewardsApr=_getFarmApr.lpRewardsApr;return _objectSpread(_objectSpread({},farm),{},{apr:cakeRewardsApr,lpRewardsApr:lpRewardsApr});});var sortedByApr=orderBy(farmsWithApr,function(farm){return farm.apr+farm.lpRewardsApr;},'desc');setTopFarms(sortedByApr.slice(0,5));};if(fetchStatus===FetchStatus.SUCCESS&&!topFarms[0]){getTopFarmsByApr(farms);}},[setTopFarms,farms,fetchStatus,cakePriceBusd,topFarms]);return{topFarms:topFarms};};export default useGetTopFarmsByApr;","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/apphocvienstock/src/views/Home/hooks/useGetTopFarmsByApr.tsx"],"names":["useState","useEffect","ChainId","useFarms","usePriceCakeBusd","useAppDispatch","fetchFarmsPublicDataAsync","nonArchivedFarms","getFarmApr","BigNumber","orderBy","FetchStatus","useGetTopFarmsByApr","isIntersecting","dispatch","farms","data","NOT_FETCHED","fetchStatus","setFetchStatus","topFarms","setTopFarms","cakePriceBusd","fetchFarmData","FETCHING","activeFarms","filter","farm","pid","multiplier","map","SUCCESS","console","error","FAILED","getTopFarmsByApr","farmsState","farmsWithPrices","lpTotalInQuoteToken","quoteToken","busdPrice","farmsWithApr","totalLiquidity","times","poolWeight","lpAddresses","MAINNET","cakeRewardsApr","lpRewardsApr","apr","sortedByApr","slice"],"mappings":"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","sourcesContent":["import { useState, useEffect } from 'react'\nimport { ChainId } from '@pancakeswap/sdk'\nimport { useFarms, usePriceCakeBusd } from 'state/farms/hooks'\nimport { useAppDispatch } from 'state'\nimport { fetchFarmsPublicDataAsync, nonArchivedFarms } from 'state/farms'\nimport { getFarmApr } from 'utils/apr'\nimport BigNumber from 'bignumber.js'\nimport { orderBy } from 'lodash'\nimport { FarmWithStakedValue } from 'views/Farms/components/FarmCard/FarmCard'\nimport { Farm } from 'state/types'\n\nenum FetchStatus {\n  NOT_FETCHED = 'not-fetched',\n  FETCHING = 'fetching',\n  SUCCESS = 'success',\n  FAILED = 'failed',\n}\n\nconst useGetTopFarmsByApr = (isIntersecting: boolean) => {\n  const dispatch = useAppDispatch()\n  const { data: farms } = useFarms()\n  const [fetchStatus, setFetchStatus] = useState(FetchStatus.NOT_FETCHED)\n  const [topFarms, setTopFarms] = useState<FarmWithStakedValue[]>([null, null, null, null, null])\n  const cakePriceBusd = usePriceCakeBusd()\n\n  useEffect(() => {\n    const fetchFarmData = async () => {\n      setFetchStatus(FetchStatus.FETCHING)\n      const activeFarms = nonArchivedFarms.filter((farm) => farm.pid !== 0 && farm.multiplier !== '0X')\n      try {\n        await dispatch(fetchFarmsPublicDataAsync(activeFarms.map((farm) => farm.pid)))\n        setFetchStatus(FetchStatus.SUCCESS)\n      } catch (e) {\n        console.error(e)\n        setFetchStatus(FetchStatus.FAILED)\n      }\n    }\n\n    if (isIntersecting && fetchStatus === FetchStatus.NOT_FETCHED) {\n      fetchFarmData()\n    }\n  }, [dispatch, setFetchStatus, fetchStatus, topFarms, isIntersecting])\n\n  useEffect(() => {\n    const getTopFarmsByApr = (farmsState: Farm[]) => {\n      const farmsWithPrices = farmsState.filter((farm) => farm.lpTotalInQuoteToken && farm.quoteToken.busdPrice)\n      const farmsWithApr: FarmWithStakedValue[] = farmsWithPrices.map((farm) => {\n        const totalLiquidity = new BigNumber(farm.lpTotalInQuoteToken).times(farm.quoteToken.busdPrice)\n        const { cakeRewardsApr, lpRewardsApr } = getFarmApr(\n          new BigNumber(farm.poolWeight),\n          cakePriceBusd,\n          totalLiquidity,\n          farm.lpAddresses[ChainId.MAINNET],\n        )\n        return { ...farm, apr: cakeRewardsApr, lpRewardsApr }\n      })\n\n      const sortedByApr = orderBy(farmsWithApr, (farm) => farm.apr + farm.lpRewardsApr, 'desc')\n      setTopFarms(sortedByApr.slice(0, 5))\n    }\n\n    if (fetchStatus === FetchStatus.SUCCESS && !topFarms[0]) {\n      getTopFarmsByApr(farms)\n    }\n  }, [setTopFarms, farms, fetchStatus, cakePriceBusd, topFarms])\n\n  return { topFarms }\n}\n\nexport default useGetTopFarmsByApr\n"]},"metadata":{},"sourceType":"module"}