{"ast":null,"code":"import _regeneratorRuntime from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import Nfts,{IPFS_GATEWAY,nftSources}from'config/constants/nfts';import{getAddress}from'./addressHelpers';import{getErc721Contract}from'./contractHelpers';/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */export var getIdentifierKeyFromAddress=function getIdentifierKeyFromAddress(nftAddress){var nftSource=Object.values(nftSources).find(function(nftSourceEntry){var address=getAddress(nftSourceEntry.address);return address===nftAddress;});return nftSource?nftSource.identifierKey:null;};/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */export var getTokenUrl=function getTokenUrl(tokenUri){if(tokenUri.startsWith('ipfs://')){return\"\".concat(IPFS_GATEWAY,\"/\").concat(tokenUri.slice(6));}return tokenUri;};export var getAddressByType=function getAddressByType(type){return getAddress(nftSources[type].address);};export var getTokenUriData=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(nftAddress,tokenId){var contract,tokenUri,uriDataResponse,uriData;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:_context.prev=0;contract=getErc721Contract(nftAddress);_context.next=4;return contract.tokenURI(tokenId);case 4:tokenUri=_context.sent;_context.next=7;return fetch(getTokenUrl(tokenUri));case 7:uriDataResponse=_context.sent;if(uriDataResponse.ok){_context.next=10;break;}return _context.abrupt(\"return\",null);case 10:_context.next=12;return uriDataResponse.json();case 12:uriData=_context.sent;return _context.abrupt(\"return\",uriData);case 16:_context.prev=16;_context.t0=_context[\"catch\"](0);console.error('getTokenUriData',_context.t0);return _context.abrupt(\"return\",null);case 20:case\"end\":return _context.stop();}}},_callee,null,[[0,16]]);}));return function getTokenUriData(_x,_x2){return _ref.apply(this,arguments);};}();export var getNftByTokenId=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(nftAddress,tokenId){var uriData,identifierKey;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:_context2.next=2;return getTokenUriData(nftAddress,tokenId);case 2:uriData=_context2.sent;identifierKey=getIdentifierKeyFromAddress(nftAddress);// Bail out early if we have no uriData, identifierKey, or the value does not\n// exist in the object\nif(uriData){_context2.next=6;break;}return _context2.abrupt(\"return\",null);case 6:if(identifierKey){_context2.next=8;break;}return _context2.abrupt(\"return\",null);case 8:if(uriData[identifierKey]){_context2.next=10;break;}return _context2.abrupt(\"return\",null);case 10:return _context2.abrupt(\"return\",Nfts.find(function(nft){return uriData[identifierKey].includes(nft.identifier);}));case 11:case\"end\":return _context2.stop();}}},_callee2);}));return function getNftByTokenId(_x3,_x4){return _ref2.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/pancake-frontend/src/utils/collectibles.ts"],"names":["Nfts","IPFS_GATEWAY","nftSources","getAddress","getErc721Contract","getIdentifierKeyFromAddress","nftAddress","nftSource","Object","values","find","nftSourceEntry","address","identifierKey","getTokenUrl","tokenUri","startsWith","slice","getAddressByType","type","getTokenUriData","tokenId","contract","tokenURI","fetch","uriDataResponse","ok","json","uriData","console","error","getNftByTokenId","nft","includes","identifier"],"mappings":"+UAAA,MAAOA,CAAAA,IAAP,EAAeC,YAAf,CAA6BC,UAA7B,KAA+C,uBAA/C,CAEA,OAASC,UAAT,KAA2B,kBAA3B,CACA,OAASC,iBAAT,KAAkC,mBAAlC,CAEA;AACA;AACA;AACA,GACA,MAAO,IAAMC,CAAAA,2BAA2B,CAAG,QAA9BA,CAAAA,2BAA8B,CAACC,UAAD,CAAwB,CACjE,GAAMC,CAAAA,SAAS,CAAGC,MAAM,CAACC,MAAP,CAAcP,UAAd,EAA0BQ,IAA1B,CAA+B,SAACC,cAAD,CAAoB,CACnE,GAAMC,CAAAA,OAAO,CAAGT,UAAU,CAACQ,cAAc,CAACC,OAAhB,CAA1B,CACA,MAAOA,CAAAA,OAAO,GAAKN,UAAnB,CACD,CAHiB,CAAlB,CAKA,MAAOC,CAAAA,SAAS,CAAGA,SAAS,CAACM,aAAb,CAA6B,IAA7C,CACD,CAPM,CASP;AACA;AACA,GACA,MAAO,IAAMC,CAAAA,WAAW,CAAG,QAAdA,CAAAA,WAAc,CAACC,QAAD,CAAsB,CAC/C,GAAIA,QAAQ,CAACC,UAAT,CAAoB,SAApB,CAAJ,CAAoC,CAClC,gBAAUf,YAAV,aAA0Bc,QAAQ,CAACE,KAAT,CAAe,CAAf,CAA1B,EACD,CAED,MAAOF,CAAAA,QAAP,CACD,CANM,CAQP,MAAO,IAAMG,CAAAA,gBAAgB,CAAG,QAAnBA,CAAAA,gBAAmB,CAACC,IAAD,CAAmB,CACjD,MAAOhB,CAAAA,UAAU,CAACD,UAAU,CAACiB,IAAD,CAAV,CAAiBP,OAAlB,CAAjB,CACD,CAFM,CAIP,MAAO,IAAMQ,CAAAA,eAAe,0FAAG,iBAAOd,UAAP,CAA2Be,OAA3B,gLAErBC,QAFqB,CAEVlB,iBAAiB,CAACE,UAAD,CAFP,uBAGJgB,CAAAA,QAAQ,CAACC,QAAT,CAAkBF,OAAlB,CAHI,QAGrBN,QAHqB,qCAIGS,CAAAA,KAAK,CAACV,WAAW,CAACC,QAAD,CAAZ,CAJR,QAIrBU,eAJqB,kBAMtBA,eAAe,CAACC,EANM,0DAOlB,IAPkB,iCAULD,CAAAA,eAAe,CAACE,IAAhB,EAVK,SAUrBC,OAVqB,+CAWpBA,OAXoB,4DAa3BC,OAAO,CAACC,KAAR,CAAc,iBAAd,cAb2B,gCAcpB,IAdoB,uEAAH,kBAAfV,CAAAA,eAAe,gDAArB,CAkBP,MAAO,IAAMW,CAAAA,eAAe,2FAAG,kBAAOzB,UAAP,CAA2Be,OAA3B,uKACPD,CAAAA,eAAe,CAACd,UAAD,CAAae,OAAb,CADR,QACvBO,OADuB,gBAEvBf,aAFuB,CAEPR,2BAA2B,CAACC,UAAD,CAFpB,CAI7B;AACA;AAL6B,GAMxBsB,OANwB,2DAOpB,IAPoB,YAUxBf,aAVwB,2DAWpB,IAXoB,YAcxBe,OAAO,CAACf,aAAD,CAdiB,4DAepB,IAfoB,2CAkBtBb,IAAI,CAACU,IAAL,CAAU,SAACsB,GAAD,CAAS,CACxB,MAAOJ,CAAAA,OAAO,CAACf,aAAD,CAAP,CAAuBoB,QAAvB,CAAgCD,GAAG,CAACE,UAApC,CAAP,CACD,CAFM,CAlBsB,2DAAH,kBAAfH,CAAAA,eAAe,kDAArB","sourcesContent":["import Nfts, { IPFS_GATEWAY, nftSources } from 'config/constants/nfts'\nimport { Nft, NftType } from 'config/constants/types'\nimport { getAddress } from './addressHelpers'\nimport { getErc721Contract } from './contractHelpers'\n\n/**\n * Gets the identifier key based on the nft address\n * Helpful for looking up the key when all you have is the address\n */\nexport const getIdentifierKeyFromAddress = (nftAddress: string) => {\n  const nftSource = Object.values(nftSources).find((nftSourceEntry) => {\n    const address = getAddress(nftSourceEntry.address)\n    return address === nftAddress\n  })\n\n  return nftSource ? nftSource.identifierKey : null\n}\n\n/**\n * Some sources like Pancake do not return HTTP tokenURI's\n */\nexport const getTokenUrl = (tokenUri: string) => {\n  if (tokenUri.startsWith('ipfs://')) {\n    return `${IPFS_GATEWAY}/${tokenUri.slice(6)}`\n  }\n\n  return tokenUri\n}\n\nexport const getAddressByType = (type: NftType) => {\n  return getAddress(nftSources[type].address)\n}\n\nexport const getTokenUriData = async (nftAddress: string, tokenId: number) => {\n  try {\n    const contract = getErc721Contract(nftAddress)\n    const tokenUri = await contract.tokenURI(tokenId)\n    const uriDataResponse = await fetch(getTokenUrl(tokenUri))\n\n    if (!uriDataResponse.ok) {\n      return null\n    }\n\n    const uriData = await uriDataResponse.json()\n    return uriData\n  } catch (error) {\n    console.error('getTokenUriData', error)\n    return null\n  }\n}\n\nexport const getNftByTokenId = async (nftAddress: string, tokenId: number): Promise<Nft | null> => {\n  const uriData = await getTokenUriData(nftAddress, tokenId)\n  const identifierKey = getIdentifierKeyFromAddress(nftAddress)\n\n  // Bail out early if we have no uriData, identifierKey, or the value does not\n  // exist in the object\n  if (!uriData) {\n    return null\n  }\n\n  if (!identifierKey) {\n    return null\n  }\n\n  if (!uriData[identifierKey]) {\n    return null\n  }\n\n  return Nfts.find((nft) => {\n    return uriData[identifierKey].includes(nft.identifier)\n  })\n}\n"]},"metadata":{},"sourceType":"module"}