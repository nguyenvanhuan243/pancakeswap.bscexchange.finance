{"ast":null,"code":"import { createAsyncThunk, createSlice } from '@reduxjs/toolkit';\nimport maxBy from 'lodash/maxBy';\nimport merge from 'lodash/merge';\nimport range from 'lodash/range';\nimport { BIG_ZERO } from 'utils/bigNumber';\nimport { HistoryFilter, PredictionStatus } from 'state/types';\nimport { getPredictionsContract } from 'utils/contractHelpers';\nimport { FUTURE_ROUND_COUNT, PAST_ROUND_COUNT, ROUND_BUFFER } from './config';\nimport { getBetHistory, transformBetResponse, makeFutureRoundResponse, makeRoundData, getRoundsData, getPredictionData, getLedgerData, makeLedgerData, serializePredictionsRoundsResponse, getClaimStatuses } from './helpers';\nconst initialState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  intervalSeconds: 300,\n  minBetAmount: '10000000000000',\n  bufferSeconds: 60,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  ledgers: {},\n  claimableStatuses: {}\n}; // Thunks\n// V2 REFACTOR\n\nexport const initializePredictions = createAsyncThunk('predictions/intialize', async (account = null) => {\n  // Static values\n  const marketData = await getPredictionData();\n  const epochs = marketData.currentEpoch > PAST_ROUND_COUNT ? range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT) : [marketData.currentEpoch]; // Round data\n\n  const roundsResponse = await getRoundsData(epochs);\n  const initialRoundData = roundsResponse.reduce((accum, roundResponse) => {\n    const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse);\n    return { ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n  const initializedData = { ...marketData,\n    rounds: initialRoundData,\n    ledgers: {},\n    claimableStatuses: {}\n  };\n\n  if (!account) {\n    return initializedData;\n  } // Bet data\n\n\n  const ledgerResponses = await getLedgerData(account, epochs); // Claim statuses\n\n  const claimableStatuses = await getClaimStatuses(account, epochs);\n  return merge({}, initializedData, {\n    ledgers: makeLedgerData(account, ledgerResponses, epochs),\n    claimableStatuses\n  });\n});\nexport const fetchRound = createAsyncThunk('predictions/fetchRound', async epoch => {\n  const predictionContract = getPredictionsContract();\n  const response = await predictionContract.rounds(epoch);\n  return serializePredictionsRoundsResponse(response);\n});\nexport const fetchRounds = createAsyncThunk('predictions/fetchRounds', async epochs => {\n  const rounds = await getRoundsData(epochs);\n  return rounds.reduce((accum, round) => {\n    if (!round) {\n      return accum;\n    }\n\n    const reduxNodeRound = serializePredictionsRoundsResponse(round);\n    return { ...accum,\n      [reduxNodeRound.epoch.toString()]: reduxNodeRound\n    };\n  }, {});\n});\nexport const fetchMarketData = createAsyncThunk('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData();\n  return marketData;\n});\nexport const fetchLedgerData = createAsyncThunk('predictions/fetchLedgerData', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getLedgerData(account, epochs);\n  return makeLedgerData(account, ledgers, epochs);\n});\nexport const fetchClaimableStatuses = createAsyncThunk('predictions/fetchClaimableStatuses', async ({\n  account,\n  epochs\n}) => {\n  const ledgers = await getClaimStatuses(account, epochs);\n  return ledgers;\n}); // END V2 REFACTOR\n\nexport const fetchHistory = createAsyncThunk('predictions/fetchHistory', async ({\n  account,\n  claimed\n}) => {\n  const response = await getBetHistory({\n    user: account.toLowerCase(),\n    claimed\n  });\n  const bets = response.map(transformBetResponse);\n  return {\n    account,\n    bets\n  };\n});\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action) => {\n      state.status = action.payload;\n    },\n    setHistoryPaneState: (state, action) => {\n      state.isHistoryPaneOpen = action.payload;\n      state.historyFilter = HistoryFilter.ALL;\n    },\n    setChartPaneState: (state, action) => {\n      state.isChartPaneOpen = action.payload;\n    },\n    setHistoryFilter: (state, action) => {\n      state.historyFilter = action.payload;\n    },\n    setCurrentEpoch: (state, action) => {\n      state.currentEpoch = action.payload;\n    },\n    setLastOraclePrice: (state, action) => {\n      state.lastOraclePrice = action.payload;\n    },\n    markBetHistoryAsCollected: (state, action) => {\n      const {\n        account,\n        betId\n      } = action.payload;\n\n      if (state.history[account]) {\n        const betIndex = state.history[account].findIndex(bet => bet.id === betId);\n\n        if (betIndex >= 0) {\n          state.history[account][betIndex].claimed = true;\n        }\n      }\n    }\n  },\n  extraReducers: builder => {\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload);\n    }); // Ledger (bet) records\n\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload);\n    }); // Get static market data\n\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        intervalSeconds,\n        minBetAmount\n      } = action.payload; // If the round has change add a new future round\n\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch');\n        const futureRound = makeFutureRoundResponse(newestRound.epoch + 1, newestRound.startTimestamp + intervalSeconds + ROUND_BUFFER);\n        state.rounds[futureRound.epoch] = futureRound;\n      }\n\n      state.status = status;\n      state.currentEpoch = currentEpoch;\n      state.intervalSeconds = intervalSeconds;\n      state.minBetAmount = minBetAmount;\n    }); // Initialize predictions\n\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const {\n        status,\n        currentEpoch,\n        intervalSeconds,\n        bufferSeconds,\n        rounds,\n        claimableStatuses,\n        ledgers\n      } = action.payload;\n      const futureRounds = [];\n      const currentRound = rounds[currentEpoch];\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(makeFutureRoundResponse(currentEpoch + i, currentRound.startTimestamp + intervalSeconds * i));\n      }\n\n      return { ...state,\n        status,\n        currentEpoch,\n        intervalSeconds,\n        bufferSeconds,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds))\n      };\n    }); // Get single round\n\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload\n      });\n    }); // Get multiple rounds\n\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload);\n    }); // Show History\n\n    builder.addCase(fetchHistory.pending, state => {\n      state.isFetchingHistory = true;\n    });\n    builder.addCase(fetchHistory.rejected, state => {\n      state.isFetchingHistory = false;\n    });\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const {\n        account,\n        bets\n      } = action.payload;\n      state.isFetchingHistory = false;\n      state.history[account] = bets;\n    });\n  }\n}); // Actions\n\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markBetHistoryAsCollected\n} = predictionsSlice.actions;\nexport default predictionsSlice.reducer;","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/apphocvienstock/src/state/predictions/index.ts"],"names":["createAsyncThunk","createSlice","maxBy","merge","range","BIG_ZERO","HistoryFilter","PredictionStatus","getPredictionsContract","FUTURE_ROUND_COUNT","PAST_ROUND_COUNT","ROUND_BUFFER","getBetHistory","transformBetResponse","makeFutureRoundResponse","makeRoundData","getRoundsData","getPredictionData","getLedgerData","makeLedgerData","serializePredictionsRoundsResponse","getClaimStatuses","initialState","status","INITIAL","isLoading","isHistoryPaneOpen","isChartPaneOpen","isFetchingHistory","historyFilter","ALL","currentEpoch","intervalSeconds","minBetAmount","bufferSeconds","lastOraclePrice","toJSON","rounds","history","ledgers","claimableStatuses","initializePredictions","account","marketData","epochs","roundsResponse","initialRoundData","reduce","accum","roundResponse","reduxNodeRound","epoch","toString","initializedData","ledgerResponses","fetchRound","predictionContract","response","fetchRounds","round","fetchMarketData","fetchLedgerData","fetchClaimableStatuses","fetchHistory","claimed","user","toLowerCase","bets","map","predictionsSlice","name","reducers","setPredictionStatus","state","action","payload","setHistoryPaneState","setChartPaneState","setHistoryFilter","setCurrentEpoch","setLastOraclePrice","markBetHistoryAsCollected","betId","betIndex","findIndex","bet","id","extraReducers","builder","addCase","fulfilled","newestRound","Object","values","futureRound","startTimestamp","futureRounds","currentRound","i","push","pending","rejected","actions","reducer"],"mappings":"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","sourcesContent":["import { createAsyncThunk, createSlice, PayloadAction } from '@reduxjs/toolkit'\nimport maxBy from 'lodash/maxBy'\nimport merge from 'lodash/merge'\nimport range from 'lodash/range'\nimport { BIG_ZERO } from 'utils/bigNumber'\nimport { Bet, LedgerData, HistoryFilter, PredictionsState, PredictionStatus, ReduxNodeRound } from 'state/types'\nimport { getPredictionsContract } from 'utils/contractHelpers'\nimport { FUTURE_ROUND_COUNT, PAST_ROUND_COUNT, ROUND_BUFFER } from './config'\nimport {\n  getBetHistory,\n  transformBetResponse,\n  makeFutureRoundResponse,\n  makeRoundData,\n  getRoundsData,\n  getPredictionData,\n  MarketData,\n  getLedgerData,\n  makeLedgerData,\n  serializePredictionsRoundsResponse,\n  getClaimStatuses,\n} from './helpers'\n\nconst initialState: PredictionsState = {\n  status: PredictionStatus.INITIAL,\n  isLoading: false,\n  isHistoryPaneOpen: false,\n  isChartPaneOpen: false,\n  isFetchingHistory: false,\n  historyFilter: HistoryFilter.ALL,\n  currentEpoch: 0,\n  intervalSeconds: 300,\n  minBetAmount: '10000000000000',\n  bufferSeconds: 60,\n  lastOraclePrice: BIG_ZERO.toJSON(),\n  rounds: {},\n  history: {},\n  ledgers: {},\n  claimableStatuses: {},\n}\n\n// Thunks\n// V2 REFACTOR\ntype PredictionInitialization = Pick<\n  PredictionsState,\n  | 'status'\n  | 'currentEpoch'\n  | 'intervalSeconds'\n  | 'minBetAmount'\n  | 'rounds'\n  | 'ledgers'\n  | 'claimableStatuses'\n  | 'bufferSeconds'\n>\nexport const initializePredictions = createAsyncThunk<PredictionInitialization, string>(\n  'predictions/intialize',\n  async (account = null) => {\n    // Static values\n    const marketData = await getPredictionData()\n    const epochs =\n      marketData.currentEpoch > PAST_ROUND_COUNT\n        ? range(marketData.currentEpoch, marketData.currentEpoch - PAST_ROUND_COUNT)\n        : [marketData.currentEpoch]\n\n    // Round data\n    const roundsResponse = await getRoundsData(epochs)\n    const initialRoundData: { [key: string]: ReduxNodeRound } = roundsResponse.reduce((accum, roundResponse) => {\n      const reduxNodeRound = serializePredictionsRoundsResponse(roundResponse)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n\n    const initializedData = {\n      ...marketData,\n      rounds: initialRoundData,\n      ledgers: {},\n      claimableStatuses: {},\n    }\n\n    if (!account) {\n      return initializedData\n    }\n\n    // Bet data\n    const ledgerResponses = await getLedgerData(account, epochs)\n\n    // Claim statuses\n    const claimableStatuses = await getClaimStatuses(account, epochs)\n\n    return merge({}, initializedData, {\n      ledgers: makeLedgerData(account, ledgerResponses, epochs),\n      claimableStatuses,\n    })\n  },\n)\n\nexport const fetchRound = createAsyncThunk<ReduxNodeRound, number>('predictions/fetchRound', async (epoch) => {\n  const predictionContract = getPredictionsContract()\n  const response = await predictionContract.rounds(epoch)\n  return serializePredictionsRoundsResponse(response)\n})\n\nexport const fetchRounds = createAsyncThunk<{ [key: string]: ReduxNodeRound }, number[]>(\n  'predictions/fetchRounds',\n  async (epochs) => {\n    const rounds = await getRoundsData(epochs)\n    return rounds.reduce((accum, round) => {\n      if (!round) {\n        return accum\n      }\n\n      const reduxNodeRound = serializePredictionsRoundsResponse(round)\n\n      return {\n        ...accum,\n        [reduxNodeRound.epoch.toString()]: reduxNodeRound,\n      }\n    }, {})\n  },\n)\n\nexport const fetchMarketData = createAsyncThunk<MarketData>('predictions/fetchMarketData', async () => {\n  const marketData = await getPredictionData()\n  return marketData\n})\n\nexport const fetchLedgerData = createAsyncThunk<LedgerData, { account: string; epochs: number[] }>(\n  'predictions/fetchLedgerData',\n  async ({ account, epochs }) => {\n    const ledgers = await getLedgerData(account, epochs)\n    return makeLedgerData(account, ledgers, epochs)\n  },\n)\n\nexport const fetchClaimableStatuses = createAsyncThunk<\n  PredictionsState['claimableStatuses'],\n  { account: string; epochs: number[] }\n>('predictions/fetchClaimableStatuses', async ({ account, epochs }) => {\n  const ledgers = await getClaimStatuses(account, epochs)\n  return ledgers\n})\n// END V2 REFACTOR\n\nexport const fetchHistory = createAsyncThunk<{ account: string; bets: Bet[] }, { account: string; claimed?: boolean }>(\n  'predictions/fetchHistory',\n  async ({ account, claimed }) => {\n    const response = await getBetHistory({\n      user: account.toLowerCase(),\n      claimed,\n    })\n    const bets = response.map(transformBetResponse)\n\n    return { account, bets }\n  },\n)\n\nexport const predictionsSlice = createSlice({\n  name: 'predictions',\n  initialState,\n  reducers: {\n    setPredictionStatus: (state, action: PayloadAction<PredictionStatus>) => {\n      state.status = action.payload\n    },\n    setHistoryPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isHistoryPaneOpen = action.payload\n      state.historyFilter = HistoryFilter.ALL\n    },\n    setChartPaneState: (state, action: PayloadAction<boolean>) => {\n      state.isChartPaneOpen = action.payload\n    },\n    setHistoryFilter: (state, action: PayloadAction<HistoryFilter>) => {\n      state.historyFilter = action.payload\n    },\n    setCurrentEpoch: (state, action: PayloadAction<number>) => {\n      state.currentEpoch = action.payload\n    },\n    setLastOraclePrice: (state, action: PayloadAction<string>) => {\n      state.lastOraclePrice = action.payload\n    },\n    markBetHistoryAsCollected: (state, action: PayloadAction<{ account: string; betId: string }>) => {\n      const { account, betId } = action.payload\n\n      if (state.history[account]) {\n        const betIndex = state.history[account].findIndex((bet) => bet.id === betId)\n\n        if (betIndex >= 0) {\n          state.history[account][betIndex].claimed = true\n        }\n      }\n    },\n  },\n  extraReducers: (builder) => {\n    // Claimable statuses\n    builder.addCase(fetchClaimableStatuses.fulfilled, (state, action) => {\n      state.claimableStatuses = merge({}, state.claimableStatuses, action.payload)\n    })\n\n    // Ledger (bet) records\n    builder.addCase(fetchLedgerData.fulfilled, (state, action) => {\n      state.ledgers = merge({}, state.ledgers, action.payload)\n    })\n\n    // Get static market data\n    builder.addCase(fetchMarketData.fulfilled, (state, action) => {\n      const { status, currentEpoch, intervalSeconds, minBetAmount } = action.payload\n\n      // If the round has change add a new future round\n      if (state.currentEpoch !== currentEpoch) {\n        const newestRound = maxBy(Object.values(state.rounds), 'epoch')\n        const futureRound = makeFutureRoundResponse(\n          newestRound.epoch + 1,\n          newestRound.startTimestamp + intervalSeconds + ROUND_BUFFER,\n        )\n\n        state.rounds[futureRound.epoch] = futureRound\n      }\n\n      state.status = status\n      state.currentEpoch = currentEpoch\n      state.intervalSeconds = intervalSeconds\n      state.minBetAmount = minBetAmount\n    })\n\n    // Initialize predictions\n    builder.addCase(initializePredictions.fulfilled, (state, action) => {\n      const { status, currentEpoch, intervalSeconds, bufferSeconds, rounds, claimableStatuses, ledgers } =\n        action.payload\n      const futureRounds: ReduxNodeRound[] = []\n      const currentRound = rounds[currentEpoch]\n\n      for (let i = 1; i <= FUTURE_ROUND_COUNT; i++) {\n        futureRounds.push(makeFutureRoundResponse(currentEpoch + i, currentRound.startTimestamp + intervalSeconds * i))\n      }\n\n      return {\n        ...state,\n        status,\n        currentEpoch,\n        intervalSeconds,\n        bufferSeconds,\n        claimableStatuses,\n        ledgers,\n        rounds: merge({}, rounds, makeRoundData(futureRounds)),\n      }\n    })\n\n    // Get single round\n    builder.addCase(fetchRound.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, {\n        [action.payload.epoch.toString()]: action.payload,\n      })\n    })\n\n    // Get multiple rounds\n    builder.addCase(fetchRounds.fulfilled, (state, action) => {\n      state.rounds = merge({}, state.rounds, action.payload)\n    })\n\n    // Show History\n    builder.addCase(fetchHistory.pending, (state) => {\n      state.isFetchingHistory = true\n    })\n    builder.addCase(fetchHistory.rejected, (state) => {\n      state.isFetchingHistory = false\n    })\n    builder.addCase(fetchHistory.fulfilled, (state, action) => {\n      const { account, bets } = action.payload\n\n      state.isFetchingHistory = false\n      state.history[account] = bets\n    })\n  },\n})\n\n// Actions\nexport const {\n  setChartPaneState,\n  setCurrentEpoch,\n  setHistoryFilter,\n  setHistoryPaneState,\n  setPredictionStatus,\n  setLastOraclePrice,\n  markBetHistoryAsCollected,\n} = predictionsSlice.actions\n\nexport default predictionsSlice.reducer\n"]},"metadata":{},"sourceType":"module"}