{"ast":null,"code":"import _slicedToArray from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/slicedToArray\";import _regeneratorRuntime from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _asyncToGenerator from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";import{getBunnySpecialLotteryContract}from'utils/contractHelpers';import{fetchUserTicketsForOneRound}from'state/lottery/getUserTicketsData';export var NO_CLAIM={canClaim:false,mintData:null};export var getLottieClaim=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(account,variationId,lotteryId){var lotteryNftContract,passesContractCheck;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:lotteryNftContract=getBunnySpecialLotteryContract();if(!lotteryId){_context.next=14;break;}_context.prev=2;_context.next=5;return lotteryNftContract.canClaimNft1(account,lotteryId);case 5:passesContractCheck=_context.sent;if(!passesContractCheck){_context.next=8;break;}return _context.abrupt(\"return\",{canClaim:true,mintData:{bunnyId:variationId,lotteryId:lotteryId,cursor:'0'}});case 8:_context.next=14;break;case 10:_context.prev=10;_context.t0=_context[\"catch\"](2);console.error(\"Failed to check canClaim for Lottie\",_context.t0);return _context.abrupt(\"return\",NO_CLAIM);case 14:return _context.abrupt(\"return\",NO_CLAIM);case 15:case\"end\":return _context.stop();}}},_callee,null,[[2,10]]);}));return function getLottieClaim(_x,_x2,_x3){return _ref.apply(this,arguments);};}();export var getLuckyClaim=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(account,variationId,userRounds){var lotteryNftContract,claimedWinningRounds,_claimedWinningRounds,winningRound,userTickets,claimedTickets,winningTicketCursor,passesContractCheck;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:lotteryNftContract=getBunnySpecialLotteryContract();claimedWinningRounds=userRounds.filter(function(round){return round.claimed;});if(!(claimedWinningRounds.length>0)){_context2.next=23;break;}_claimedWinningRounds=_slicedToArray(claimedWinningRounds,1),winningRound=_claimedWinningRounds[0];_context2.next=6;return fetchUserTicketsForOneRound(account,winningRound.lotteryId);case 6:userTickets=_context2.sent;claimedTickets=userTickets.filter(function(ticket){return ticket.status;});winningTicketCursor=userTickets.indexOf(claimedTickets[0]);// No winning ticket found for an expected winning round. Can happen when switching accounts.\nif(!(winningTicketCursor<0)){_context2.next=11;break;}return _context2.abrupt(\"return\",NO_CLAIM);case 11:_context2.prev=11;_context2.next=14;return lotteryNftContract.canClaimNft2(account,winningRound.lotteryId,winningTicketCursor.toString());case 14:passesContractCheck=_context2.sent;if(!passesContractCheck){_context2.next=17;break;}return _context2.abrupt(\"return\",{canClaim:true,mintData:{bunnyId:variationId,lotteryId:winningRound.lotteryId,cursor:winningTicketCursor.toString()}});case 17:_context2.next=23;break;case 19:_context2.prev=19;_context2.t0=_context2[\"catch\"](11);console.error(\"Failed to check canClaim for Lucky\",_context2.t0);return _context2.abrupt(\"return\",NO_CLAIM);case 23:return _context2.abrupt(\"return\",NO_CLAIM);case 24:case\"end\":return _context2.stop();}}},_callee2,null,[[11,19]]);}));return function getLuckyClaim(_x4,_x5,_x6){return _ref2.apply(this,arguments);};}();export var getBallerClaim=/*#__PURE__*/function(){var _ref3=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee3(account,variationId,lotteryId){var lotteryNftContract,isWhitelisted,passesContractCheck;return _regeneratorRuntime.wrap(function _callee3$(_context3){while(1){switch(_context3.prev=_context3.next){case 0:lotteryNftContract=getBunnySpecialLotteryContract();_context3.prev=1;_context3.next=4;return lotteryNftContract.userWhitelistForNft3(account);case 4:isWhitelisted=_context3.sent;if(!isWhitelisted){_context3.next=18;break;}_context3.prev=6;_context3.next=9;return lotteryNftContract.canClaimNft3(account);case 9:passesContractCheck=_context3.sent;if(!passesContractCheck){_context3.next=12;break;}return _context3.abrupt(\"return\",{canClaim:true,mintData:{bunnyId:variationId,lotteryId:lotteryId,cursor:'0'}});case 12:_context3.next=18;break;case 14:_context3.prev=14;_context3.t0=_context3[\"catch\"](6);console.error(\"Failed to check canClaim for Baller\",_context3.t0);return _context3.abrupt(\"return\",NO_CLAIM);case 18:_context3.next=24;break;case 20:_context3.prev=20;_context3.t1=_context3[\"catch\"](1);console.error(\"Failed to check whitelist for \".concat(account),_context3.t1);return _context3.abrupt(\"return\",NO_CLAIM);case 24:return _context3.abrupt(\"return\",NO_CLAIM);case 25:case\"end\":return _context3.stop();}}},_callee3,null,[[1,20],[6,14]]);}));return function getBallerClaim(_x7,_x8,_x9){return _ref3.apply(this,arguments);};}();","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/pancake-frontend/src/views/Collectibles/helpers.ts"],"names":["getBunnySpecialLotteryContract","fetchUserTicketsForOneRound","NO_CLAIM","canClaim","mintData","getLottieClaim","account","variationId","lotteryId","lotteryNftContract","canClaimNft1","passesContractCheck","bunnyId","cursor","console","error","getLuckyClaim","userRounds","claimedWinningRounds","filter","round","claimed","length","winningRound","userTickets","claimedTickets","ticket","status","winningTicketCursor","indexOf","canClaimNft2","toString","getBallerClaim","userWhitelistForNft3","isWhitelisted","canClaimNft3"],"mappings":"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","sourcesContent":["import { getBunnySpecialLotteryContract } from 'utils/contractHelpers'\nimport { UserRound } from 'state/types'\nimport { fetchUserTicketsForOneRound } from 'state/lottery/getUserTicketsData'\n\nexport interface LotteryNftMintData {\n  bunnyId: number | string\n  lotteryId: string\n  cursor: string\n}\n\nexport interface NftClaim {\n  canClaim: boolean\n  mintData: LotteryNftMintData\n}\n\nexport const NO_CLAIM: NftClaim = {\n  canClaim: false,\n  mintData: null,\n}\n\nexport const getLottieClaim = async (\n  account: string,\n  variationId: number | string,\n  lotteryId: string,\n): Promise<NftClaim> => {\n  const lotteryNftContract = getBunnySpecialLotteryContract()\n\n  if (lotteryId) {\n    try {\n      const passesContractCheck = await lotteryNftContract.canClaimNft1(account, lotteryId)\n\n      if (passesContractCheck) {\n        return {\n          canClaim: true,\n          mintData: { bunnyId: variationId, lotteryId, cursor: '0' },\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to check canClaim for Lottie`, error)\n      return NO_CLAIM\n    }\n  }\n\n  return NO_CLAIM\n}\n\nexport const getLuckyClaim = async (\n  account: string,\n  variationId: number | string,\n  userRounds: UserRound[],\n): Promise<NftClaim> => {\n  const lotteryNftContract = getBunnySpecialLotteryContract()\n\n  const claimedWinningRounds = userRounds.filter((round) => round.claimed)\n  if (claimedWinningRounds.length > 0) {\n    const [winningRound] = claimedWinningRounds\n    const userTickets = await fetchUserTicketsForOneRound(account, winningRound.lotteryId)\n    const claimedTickets = userTickets.filter((ticket) => ticket.status)\n    const winningTicketCursor = userTickets.indexOf(claimedTickets[0])\n    // No winning ticket found for an expected winning round. Can happen when switching accounts.\n    if (winningTicketCursor < 0) {\n      return NO_CLAIM\n    }\n    try {\n      const passesContractCheck = await lotteryNftContract.canClaimNft2(\n        account,\n        winningRound.lotteryId,\n        winningTicketCursor.toString(),\n      )\n      if (passesContractCheck) {\n        return {\n          canClaim: true,\n          mintData: {\n            bunnyId: variationId,\n            lotteryId: winningRound.lotteryId,\n            cursor: winningTicketCursor.toString(),\n          },\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to check canClaim for Lucky`, error)\n      return NO_CLAIM\n    }\n  }\n  return NO_CLAIM\n}\n\nexport const getBallerClaim = async (\n  account: string,\n  variationId: number | string,\n  lotteryId?: string,\n): Promise<NftClaim> => {\n  const lotteryNftContract = getBunnySpecialLotteryContract()\n\n  try {\n    const isWhitelisted = await lotteryNftContract.userWhitelistForNft3(account)\n    if (isWhitelisted) {\n      try {\n        const passesContractCheck = await lotteryNftContract.canClaimNft3(account)\n        if (passesContractCheck) {\n          return {\n            canClaim: true,\n            mintData: { bunnyId: variationId, lotteryId, cursor: '0' },\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to check canClaim for Baller`, error)\n        return NO_CLAIM\n      }\n    }\n  } catch (error) {\n    console.error(`Failed to check whitelist for ${account}`, error)\n    return NO_CLAIM\n  }\n  return NO_CLAIM\n}\n"]},"metadata":{},"sourceType":"module"}