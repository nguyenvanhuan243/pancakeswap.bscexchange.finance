{"ast":null,"code":"import _objectSpread from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/objectSpread2\";import _regeneratorRuntime from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/regenerator\";import _taggedTemplateLiteral from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/taggedTemplateLiteral\";import _asyncToGenerator from\"/Users/nguyenvanhuan243/Documents/pancake-frontend/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/asyncToGenerator\";var _templateObject;import{request,gql}from'graphql-request';import{GRAPH_API_LOTTERY}from'config/constants/endpoints';import{getRoundIdsArray,fetchMultipleLotteries,hasRoundBeenClaimed}from'./helpers';import{fetchUserTicketsForMultipleRounds}from'./getUserTicketsData';var MAX_USER_LOTTERIES_REQUEST_SIZE=100;/* eslint-disable camelcase */var applyNodeDataToUserGraphResponse=function applyNodeDataToUserGraphResponse(userNodeData,userGraphData,lotteryNodeData){//   If no graph rounds response - return node data\nif(userGraphData.length===0){return lotteryNodeData.map(function(nodeRound){var ticketDataForRound=userNodeData.find(function(roundTickets){return roundTickets.roundId===nodeRound.lotteryId;});return{endTime:nodeRound.endTime,status:nodeRound.status,lotteryId:nodeRound.lotteryId.toString(),claimed:hasRoundBeenClaimed(ticketDataForRound.userTickets),totalTickets:\"\".concat(ticketDataForRound.userTickets.length.toString()),tickets:ticketDataForRound.userTickets};});}//   Else if there is a graph response - merge with node data where node data is more accurate\nvar mergedResponse=userGraphData.map(function(graphRound,index){var nodeRound=lotteryNodeData[index];// if there is node data for this index, overwrite graph data. Otherwise - return graph data.\nif(nodeRound){var ticketDataForRound=userNodeData.find(function(roundTickets){return roundTickets.roundId===nodeRound.lotteryId;});// if isLoading === true, there has been a node error - return graphRound\nif(!nodeRound.isLoading){return{endTime:nodeRound.endTime,status:nodeRound.status,lotteryId:nodeRound.lotteryId.toString(),claimed:hasRoundBeenClaimed(ticketDataForRound.userTickets),totalTickets:graphRound.totalTickets,tickets:ticketDataForRound.userTickets};}return graphRound;}return graphRound;});return mergedResponse;};export var getGraphLotteryUser=/*#__PURE__*/function(){var _ref=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee(account){var first,skip,where,user,blankUser,response,userRes,_args=arguments;return _regeneratorRuntime.wrap(function _callee$(_context){while(1){switch(_context.prev=_context.next){case 0:first=_args.length>1&&_args[1]!==undefined?_args[1]:MAX_USER_LOTTERIES_REQUEST_SIZE;skip=_args.length>2&&_args[2]!==undefined?_args[2]:0;where=_args.length>3&&_args[3]!==undefined?_args[3]:{};blankUser={account:account,totalCake:'',totalTickets:'',rounds:[]};_context.prev=4;_context.next=7;return request(GRAPH_API_LOTTERY,gql(_templateObject||(_templateObject=_taggedTemplateLiteral([\"\\n        query getUserLotteries($account: ID!, $first: Int!, $skip: Int!, $where: Round_filter) {\\n          user(id: $account) {\\n            id\\n            totalTickets\\n            totalCake\\n            rounds(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\\n              id\\n              lottery {\\n                id\\n                endTime\\n                status\\n              }\\n              claimed\\n              totalTickets\\n            }\\n          }\\n        }\\n      \"]))),{account:account.toLowerCase(),first:first,skip:skip,where:where});case 7:response=_context.sent;userRes=response.user;// If no user returned - return blank user\nif(!userRes){user=blankUser;}else{user={account:userRes.id,totalCake:userRes.totalCake,totalTickets:userRes.totalTickets,rounds:userRes.rounds.map(function(round){var _round$lottery,_round$lottery2,_round$lottery3;return{lotteryId:round===null||round===void 0?void 0:(_round$lottery=round.lottery)===null||_round$lottery===void 0?void 0:_round$lottery.id,endTime:round===null||round===void 0?void 0:(_round$lottery2=round.lottery)===null||_round$lottery2===void 0?void 0:_round$lottery2.endTime,claimed:round===null||round===void 0?void 0:round.claimed,totalTickets:round===null||round===void 0?void 0:round.totalTickets,status:round===null||round===void 0?void 0:(_round$lottery3=round.lottery)===null||_round$lottery3===void 0?void 0:_round$lottery3.status};})};}_context.next=16;break;case 12:_context.prev=12;_context.t0=_context[\"catch\"](4);console.error(_context.t0);user=blankUser;case 16:return _context.abrupt(\"return\",user);case 17:case\"end\":return _context.stop();}}},_callee,null,[[4,12]]);}));return function getGraphLotteryUser(_x){return _ref.apply(this,arguments);};}();var getUserLotteryData=/*#__PURE__*/function(){var _ref2=_asyncToGenerator(/*#__PURE__*/_regeneratorRuntime.mark(function _callee2(account,currentLotteryId){var idsForTicketsNodeCall,roundDataAndUserTickets,userRoundsNodeData,idsForLotteriesNodeCall,lotteriesNodeData,graphResponse,mergedRoundData,graphResponseWithNodeRounds;return _regeneratorRuntime.wrap(function _callee2$(_context2){while(1){switch(_context2.prev=_context2.next){case 0:idsForTicketsNodeCall=getRoundIdsArray(currentLotteryId);_context2.next=3;return fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall,account);case 3:roundDataAndUserTickets=_context2.sent;userRoundsNodeData=roundDataAndUserTickets.filter(function(round){return round.userTickets.length>0;});idsForLotteriesNodeCall=userRoundsNodeData.map(function(round){return round.roundId;});_context2.next=8;return fetchMultipleLotteries(idsForLotteriesNodeCall);case 8:lotteriesNodeData=_context2.sent;_context2.next=11;return getGraphLotteryUser(account);case 11:graphResponse=_context2.sent;mergedRoundData=applyNodeDataToUserGraphResponse(userRoundsNodeData,graphResponse.rounds,lotteriesNodeData);graphResponseWithNodeRounds=_objectSpread(_objectSpread({},graphResponse),{},{rounds:mergedRoundData});return _context2.abrupt(\"return\",graphResponseWithNodeRounds);case 15:case\"end\":return _context2.stop();}}},_callee2);}));return function getUserLotteryData(_x2,_x3){return _ref2.apply(this,arguments);};}();export default getUserLotteryData;","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/pancake-frontend/src/state/lottery/getUserLotteryData.ts"],"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","hasRoundBeenClaimed","fetchUserTicketsForMultipleRounds","MAX_USER_LOTTERIES_REQUEST_SIZE","applyNodeDataToUserGraphResponse","userNodeData","userGraphData","lotteryNodeData","length","map","nodeRound","ticketDataForRound","find","roundTickets","roundId","lotteryId","endTime","status","toString","claimed","userTickets","totalTickets","tickets","mergedResponse","graphRound","index","isLoading","getGraphLotteryUser","account","first","skip","where","blankUser","totalCake","rounds","toLowerCase","response","userRes","user","id","round","lottery","console","error","getUserLotteryData","currentLotteryId","idsForTicketsNodeCall","roundDataAndUserTickets","userRoundsNodeData","filter","idsForLotteriesNodeCall","lotteriesNodeData","graphResponse","mergedRoundData","graphResponseWithNodeRounds"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\nimport { LotteryTicket } from 'config/constants/types'\nimport { LotteryUserGraphEntity, LotteryResponse, UserRound } from 'state/types'\nimport { getRoundIdsArray, fetchMultipleLotteries, hasRoundBeenClaimed } from './helpers'\nimport { fetchUserTicketsForMultipleRounds } from './getUserTicketsData'\n\nconst MAX_USER_LOTTERIES_REQUEST_SIZE = 100\n\n/* eslint-disable camelcase */\ntype UserLotteriesWhere = { lottery_in?: string[] }\n\nconst applyNodeDataToUserGraphResponse = (\n  userNodeData: { roundId: string; userTickets: LotteryTicket[] }[],\n  userGraphData: UserRound[],\n  lotteryNodeData: LotteryResponse[],\n): UserRound[] => {\n  //   If no graph rounds response - return node data\n  if (userGraphData.length === 0) {\n    return lotteryNodeData.map((nodeRound) => {\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\n      return {\n        endTime: nodeRound.endTime,\n        status: nodeRound.status,\n        lotteryId: nodeRound.lotteryId.toString(),\n        claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n        totalTickets: `${ticketDataForRound.userTickets.length.toString()}`,\n        tickets: ticketDataForRound.userTickets,\n      }\n    })\n  }\n\n  //   Else if there is a graph response - merge with node data where node data is more accurate\n  const mergedResponse = userGraphData.map((graphRound, index) => {\n    const nodeRound = lotteryNodeData[index]\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n    if (nodeRound) {\n      const ticketDataForRound = userNodeData.find((roundTickets) => roundTickets.roundId === nodeRound.lotteryId)\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          status: nodeRound.status,\n          lotteryId: nodeRound.lotteryId.toString(),\n          claimed: hasRoundBeenClaimed(ticketDataForRound.userTickets),\n          totalTickets: graphRound.totalTickets,\n          tickets: ticketDataForRound.userTickets,\n        }\n      }\n      return graphRound\n    }\n    return graphRound\n  })\n  return mergedResponse\n}\n\nexport const getGraphLotteryUser = async (\n  account: string,\n  first = MAX_USER_LOTTERIES_REQUEST_SIZE,\n  skip = 0,\n  where: UserLotteriesWhere = {},\n): Promise<LotteryUserGraphEntity> => {\n  let user\n  const blankUser = {\n    account,\n    totalCake: '',\n    totalTickets: '',\n    rounds: [],\n  }\n\n  try {\n    const response = await request(\n      GRAPH_API_LOTTERY,\n      gql`\n        query getUserLotteries($account: ID!, $first: Int!, $skip: Int!, $where: Round_filter) {\n          user(id: $account) {\n            id\n            totalTickets\n            totalCake\n            rounds(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n              id\n              lottery {\n                id\n                endTime\n                status\n              }\n              claimed\n              totalTickets\n            }\n          }\n        }\n      `,\n      { account: account.toLowerCase(), first, skip, where },\n    )\n    const userRes = response.user\n\n    // If no user returned - return blank user\n    if (!userRes) {\n      user = blankUser\n    } else {\n      user = {\n        account: userRes.id,\n        totalCake: userRes.totalCake,\n        totalTickets: userRes.totalTickets,\n        rounds: userRes.rounds.map((round) => {\n          return {\n            lotteryId: round?.lottery?.id,\n            endTime: round?.lottery?.endTime,\n            claimed: round?.claimed,\n            totalTickets: round?.totalTickets,\n            status: round?.lottery?.status,\n          }\n        }),\n      }\n    }\n  } catch (error) {\n    console.error(error)\n    user = blankUser\n  }\n\n  return user\n}\n\nconst getUserLotteryData = async (account: string, currentLotteryId: string): Promise<LotteryUserGraphEntity> => {\n  const idsForTicketsNodeCall = getRoundIdsArray(currentLotteryId)\n  const roundDataAndUserTickets = await fetchUserTicketsForMultipleRounds(idsForTicketsNodeCall, account)\n  const userRoundsNodeData = roundDataAndUserTickets.filter((round) => round.userTickets.length > 0)\n  const idsForLotteriesNodeCall = userRoundsNodeData.map((round) => round.roundId)\n\n  const lotteriesNodeData = await fetchMultipleLotteries(idsForLotteriesNodeCall)\n  const graphResponse = await getGraphLotteryUser(account)\n  const mergedRoundData = applyNodeDataToUserGraphResponse(userRoundsNodeData, graphResponse.rounds, lotteriesNodeData)\n  const graphResponseWithNodeRounds = { ...graphResponse, rounds: mergedRoundData }\n  return graphResponseWithNodeRounds\n}\n\nexport default getUserLotteryData\n"]},"metadata":{},"sourceType":"module"}