{"ast":null,"code":"import { request, gql } from 'graphql-request';\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints';\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers';\nexport const MAX_LOTTERIES_REQUEST_SIZE = 100;\n/* eslint-disable camelcase */\n\nconst applyNodeDataToLotteriesGraphResponse = (nodeData, graphResponse) => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map(nodeRound => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: ''\n      };\n    });\n  } //   Else if there is a graph response - merge with node data where node data is more reliable\n\n\n  const mergedResponse = graphResponse.map((graphRound, index) => {\n    const nodeRound = nodeData[index]; // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n\n    if (nodeRound) {\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          finalNumber: nodeRound.finalNumber.toString(),\n          startTime: nodeRound.startTime,\n          status: nodeRound.status,\n          id: graphRound.id,\n          ticketPrice: graphRound.ticketPrice,\n          totalTickets: graphRound.totalTickets,\n          totalUsers: graphRound.totalUsers,\n          winningTickets: graphRound.winningTickets\n        };\n      }\n\n      return graphRound;\n    }\n\n    return graphRound;\n  });\n  return mergedResponse;\n};\n\nexport const getGraphLotteries = async (first = MAX_LOTTERIES_REQUEST_SIZE, skip = 0, where = {}) => {\n  try {\n    const response = await request(GRAPH_API_LOTTERY, gql`\n        query getLotteries($first: Int!, $skip: Int!, $where: Lottery_filter) {\n          lotteries(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `, {\n      skip,\n      first,\n      where\n    });\n    return response.lotteries;\n  } catch (error) {\n    console.error(error);\n    return [];\n  }\n};\n\nconst getLotteriesData = async currentLotteryId => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId);\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall);\n  const graphResponse = await getGraphLotteries();\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse);\n  return mergedData;\n};\n\nexport default getLotteriesData;","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/pancake-frontend/src/state/lottery/getLotteriesData.ts"],"names":["request","gql","GRAPH_API_LOTTERY","getRoundIdsArray","fetchMultipleLotteries","MAX_LOTTERIES_REQUEST_SIZE","applyNodeDataToLotteriesGraphResponse","nodeData","graphResponse","length","map","nodeRound","endTime","finalNumber","toString","startTime","status","id","lotteryId","ticketPrice","priceTicketInCake","totalTickets","totalUsers","winningTickets","mergedResponse","graphRound","index","isLoading","getGraphLotteries","first","skip","where","response","lotteries","error","console","getLotteriesData","currentLotteryId","idsForNodesCall","mergedData"],"mappings":"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","sourcesContent":["import { request, gql } from 'graphql-request'\nimport { GRAPH_API_LOTTERY } from 'config/constants/endpoints'\nimport { LotteryRoundGraphEntity, LotteryResponse } from 'state/types'\nimport { getRoundIdsArray, fetchMultipleLotteries } from './helpers'\n\nexport const MAX_LOTTERIES_REQUEST_SIZE = 100\n\n/* eslint-disable camelcase */\ntype LotteriesWhere = { id_in?: string[] }\n\nconst applyNodeDataToLotteriesGraphResponse = (\n  nodeData: LotteryResponse[],\n  graphResponse: LotteryRoundGraphEntity[],\n): LotteryRoundGraphEntity[] => {\n  //   If no graph response - return node data\n  if (graphResponse.length === 0) {\n    return nodeData.map((nodeRound) => {\n      return {\n        endTime: nodeRound.endTime,\n        finalNumber: nodeRound.finalNumber.toString(),\n        startTime: nodeRound.startTime,\n        status: nodeRound.status,\n        id: nodeRound.lotteryId.toString(),\n        ticketPrice: nodeRound.priceTicketInCake,\n        totalTickets: '',\n        totalUsers: '',\n        winningTickets: '',\n      }\n    })\n  }\n\n  //   Else if there is a graph response - merge with node data where node data is more reliable\n  const mergedResponse = graphResponse.map((graphRound, index) => {\n    const nodeRound = nodeData[index]\n    // if there is node data for this index, overwrite graph data. Otherwise - return graph data.\n    if (nodeRound) {\n      // if isLoading === true, there has been a node error - return graphRound\n      if (!nodeRound.isLoading) {\n        return {\n          endTime: nodeRound.endTime,\n          finalNumber: nodeRound.finalNumber.toString(),\n          startTime: nodeRound.startTime,\n          status: nodeRound.status,\n          id: graphRound.id,\n          ticketPrice: graphRound.ticketPrice,\n          totalTickets: graphRound.totalTickets,\n          totalUsers: graphRound.totalUsers,\n          winningTickets: graphRound.winningTickets,\n        }\n      }\n      return graphRound\n    }\n    return graphRound\n  })\n  return mergedResponse\n}\n\nexport const getGraphLotteries = async (\n  first = MAX_LOTTERIES_REQUEST_SIZE,\n  skip = 0,\n  where: LotteriesWhere = {},\n): Promise<LotteryRoundGraphEntity[]> => {\n  try {\n    const response = await request(\n      GRAPH_API_LOTTERY,\n      gql`\n        query getLotteries($first: Int!, $skip: Int!, $where: Lottery_filter) {\n          lotteries(first: $first, skip: $skip, where: $where, orderDirection: desc, orderBy: block) {\n            id\n            totalUsers\n            totalTickets\n            winningTickets\n            status\n            finalNumber\n            startTime\n            endTime\n            ticketPrice\n          }\n        }\n      `,\n      { skip, first, where },\n    )\n    return response.lotteries\n  } catch (error) {\n    console.error(error)\n    return []\n  }\n}\n\nconst getLotteriesData = async (currentLotteryId: string): Promise<LotteryRoundGraphEntity[]> => {\n  const idsForNodesCall = getRoundIdsArray(currentLotteryId)\n  const nodeData = await fetchMultipleLotteries(idsForNodesCall)\n  const graphResponse = await getGraphLotteries()\n  const mergedData = applyNodeDataToLotteriesGraphResponse(nodeData, graphResponse)\n  return mergedData\n}\n\nexport default getLotteriesData\n"]},"metadata":{},"sourceType":"module"}