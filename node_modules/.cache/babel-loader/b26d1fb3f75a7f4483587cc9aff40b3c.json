{"ast":null,"code":"import { getBunnySpecialLotteryContract } from 'utils/contractHelpers';\nimport { fetchUserTicketsForOneRound } from 'state/lottery/getUserTicketsData';\nexport const NO_CLAIM = {\n  canClaim: false,\n  mintData: null\n};\nexport const getLottieClaim = async (account, variationId, lotteryId) => {\n  const lotteryNftContract = getBunnySpecialLotteryContract();\n\n  if (lotteryId) {\n    try {\n      const passesContractCheck = await lotteryNftContract.canClaimNft1(account, lotteryId);\n\n      if (passesContractCheck) {\n        return {\n          canClaim: true,\n          mintData: {\n            bunnyId: variationId,\n            lotteryId,\n            cursor: '0'\n          }\n        };\n      }\n    } catch (error) {\n      console.error(`Failed to check canClaim for Lottie`, error);\n      return NO_CLAIM;\n    }\n  }\n\n  return NO_CLAIM;\n};\nexport const getLuckyClaim = async (account, variationId, userRounds) => {\n  const lotteryNftContract = getBunnySpecialLotteryContract();\n  const claimedWinningRounds = userRounds.filter(round => round.claimed);\n\n  if (claimedWinningRounds.length > 0) {\n    const [winningRound] = claimedWinningRounds;\n    const userTickets = await fetchUserTicketsForOneRound(account, winningRound.lotteryId);\n    const claimedTickets = userTickets.filter(ticket => ticket.status);\n    const winningTicketCursor = userTickets.indexOf(claimedTickets[0]); // No winning ticket found for an expected winning round. Can happen when switching accounts.\n\n    if (winningTicketCursor < 0) {\n      return NO_CLAIM;\n    }\n\n    try {\n      const passesContractCheck = await lotteryNftContract.canClaimNft2(account, winningRound.lotteryId, winningTicketCursor.toString());\n\n      if (passesContractCheck) {\n        return {\n          canClaim: true,\n          mintData: {\n            bunnyId: variationId,\n            lotteryId: winningRound.lotteryId,\n            cursor: winningTicketCursor.toString()\n          }\n        };\n      }\n    } catch (error) {\n      console.error(`Failed to check canClaim for Lucky`, error);\n      return NO_CLAIM;\n    }\n  }\n\n  return NO_CLAIM;\n};\nexport const getBallerClaim = async (account, variationId, lotteryId) => {\n  const lotteryNftContract = getBunnySpecialLotteryContract();\n\n  try {\n    const isWhitelisted = await lotteryNftContract.userWhitelistForNft3(account);\n\n    if (isWhitelisted) {\n      try {\n        const passesContractCheck = await lotteryNftContract.canClaimNft3(account);\n\n        if (passesContractCheck) {\n          return {\n            canClaim: true,\n            mintData: {\n              bunnyId: variationId,\n              lotteryId,\n              cursor: '0'\n            }\n          };\n        }\n      } catch (error) {\n        console.error(`Failed to check canClaim for Baller`, error);\n        return NO_CLAIM;\n      }\n    }\n  } catch (error) {\n    console.error(`Failed to check whitelist for ${account}`, error);\n    return NO_CLAIM;\n  }\n\n  return NO_CLAIM;\n};","map":{"version":3,"sources":["/Users/nguyenvanhuan243/Documents/apphocvienstock/src/views/Collectibles/helpers.ts"],"names":["getBunnySpecialLotteryContract","fetchUserTicketsForOneRound","NO_CLAIM","canClaim","mintData","getLottieClaim","account","variationId","lotteryId","lotteryNftContract","passesContractCheck","canClaimNft1","bunnyId","cursor","error","console","getLuckyClaim","userRounds","claimedWinningRounds","filter","round","claimed","length","winningRound","userTickets","claimedTickets","ticket","status","winningTicketCursor","indexOf","canClaimNft2","toString","getBallerClaim","isWhitelisted","userWhitelistForNft3","canClaimNft3"],"mappings":"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","sourcesContent":["import { getBunnySpecialLotteryContract } from 'utils/contractHelpers'\nimport { UserRound } from 'state/types'\nimport { fetchUserTicketsForOneRound } from 'state/lottery/getUserTicketsData'\n\nexport interface LotteryNftMintData {\n  bunnyId: number | string\n  lotteryId: string\n  cursor: string\n}\n\nexport interface NftClaim {\n  canClaim: boolean\n  mintData: LotteryNftMintData\n}\n\nexport const NO_CLAIM: NftClaim = {\n  canClaim: false,\n  mintData: null,\n}\n\nexport const getLottieClaim = async (\n  account: string,\n  variationId: number | string,\n  lotteryId: string,\n): Promise<NftClaim> => {\n  const lotteryNftContract = getBunnySpecialLotteryContract()\n\n  if (lotteryId) {\n    try {\n      const passesContractCheck = await lotteryNftContract.canClaimNft1(account, lotteryId)\n\n      if (passesContractCheck) {\n        return {\n          canClaim: true,\n          mintData: { bunnyId: variationId, lotteryId, cursor: '0' },\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to check canClaim for Lottie`, error)\n      return NO_CLAIM\n    }\n  }\n\n  return NO_CLAIM\n}\n\nexport const getLuckyClaim = async (\n  account: string,\n  variationId: number | string,\n  userRounds: UserRound[],\n): Promise<NftClaim> => {\n  const lotteryNftContract = getBunnySpecialLotteryContract()\n\n  const claimedWinningRounds = userRounds.filter((round) => round.claimed)\n  if (claimedWinningRounds.length > 0) {\n    const [winningRound] = claimedWinningRounds\n    const userTickets = await fetchUserTicketsForOneRound(account, winningRound.lotteryId)\n    const claimedTickets = userTickets.filter((ticket) => ticket.status)\n    const winningTicketCursor = userTickets.indexOf(claimedTickets[0])\n    // No winning ticket found for an expected winning round. Can happen when switching accounts.\n    if (winningTicketCursor < 0) {\n      return NO_CLAIM\n    }\n    try {\n      const passesContractCheck = await lotteryNftContract.canClaimNft2(\n        account,\n        winningRound.lotteryId,\n        winningTicketCursor.toString(),\n      )\n      if (passesContractCheck) {\n        return {\n          canClaim: true,\n          mintData: {\n            bunnyId: variationId,\n            lotteryId: winningRound.lotteryId,\n            cursor: winningTicketCursor.toString(),\n          },\n        }\n      }\n    } catch (error) {\n      console.error(`Failed to check canClaim for Lucky`, error)\n      return NO_CLAIM\n    }\n  }\n  return NO_CLAIM\n}\n\nexport const getBallerClaim = async (\n  account: string,\n  variationId: number | string,\n  lotteryId?: string,\n): Promise<NftClaim> => {\n  const lotteryNftContract = getBunnySpecialLotteryContract()\n\n  try {\n    const isWhitelisted = await lotteryNftContract.userWhitelistForNft3(account)\n    if (isWhitelisted) {\n      try {\n        const passesContractCheck = await lotteryNftContract.canClaimNft3(account)\n        if (passesContractCheck) {\n          return {\n            canClaim: true,\n            mintData: { bunnyId: variationId, lotteryId, cursor: '0' },\n          }\n        }\n      } catch (error) {\n        console.error(`Failed to check canClaim for Baller`, error)\n        return NO_CLAIM\n      }\n    }\n  } catch (error) {\n    console.error(`Failed to check whitelist for ${account}`, error)\n    return NO_CLAIM\n  }\n  return NO_CLAIM\n}\n"]},"metadata":{},"sourceType":"module"}